"""
Navigation Plan Entity
Fields:
- planId: string (unique identifier for the navigation plan)
- goals: NavigationGoal[] (list of navigation goals)
- globalPlan: Path (the global path generated by the global planner)
- localPlan: Path (the local path updated by the local planner)
- costmap: Costmap (costmap used for planning)
- plannerStatus: string (status of the planner)
"""
from dataclasses import dataclass
from typing import List, Optional
from .navigation_goal import NavigationGoal, Pose
from .simulation_environment import Vector3


@dataclass
class Costmap:
    """Represents a costmap used for navigation planning."""
    resolution: float  # meters per pixel
    width: int  # number of cells in x direction
    height: int  # number of cells in y direction
    origin: Vector3  # world coordinates of the bottom-left corner
    data: List[int]  # 1D array of cost values [0-255], where 0 is free and 255 is occupied
    
    def __post_init__(self):
        expected_size = self.width * self.height
        if len(self.data) != expected_size:
            raise ValueError(f"Data array size ({len(self.data)}) does not match "
                           f"expected size ({expected_size}) for width={self.width}, "
                           f"height={self.height}")

    def get_cost(self, x: int, y: int) -> Optional[int]:
        """Get the cost value at a specific cell."""
        if 0 <= x < self.width and 0 <= y < self.height:
            index = y * self.width + x
            return self.data[index]
        return None

    def set_cost(self, x: int, y: int, cost: int) -> bool:
        """Set the cost value at a specific cell."""
        if 0 <= x < self.width and 0 <= y < self.height and 0 <= cost <= 255:
            index = y * self.width + x
            self.data[index] = cost
            return True
        return False


@dataclass
class Path:
    """Represents a navigation path as a sequence of poses."""
    poses: List[Pose]
    frame_id: str  # Coordinate frame for the path
    
    def __post_init__(self):
        if self.poses is None:
            self.poses = []

    def add_pose(self, pose: Pose):
        """Add a pose to the path."""
        if not isinstance(pose, Pose):
            raise ValueError("pose must be a Pose object")
        self.poses.append(pose)

    def get_length(self) -> float:
        """Calculate the total length of the path."""
        if len(self.poses) < 2:
            return 0.0
        
        total_length = 0.0
        for i in range(1, len(self.poses)):
            prev_pos = self.poses[i-1].position
            curr_pos = self.poses[i].position
            dx = curr_pos.x - prev_pos.x
            dy = curr_pos.y - prev_pos.y
            dz = curr_pos.z - prev_pos.z
            segment_length = (dx**2 + dy**2 + dz**2) ** 0.5
            total_length += segment_length
        
        return total_length


@dataclass
class NavigationPlan:
    """Represents a navigation plan in Isaac Sim/ROS Nav2."""
    plan_id: str
    frame_id: str  # Coordinate frame for the plan
    global_plan: Path  # The global path generated by the global planner
    
    # Optional fields
    goals: List[NavigationGoal] = None
    local_plan: Optional[Path] = None
    costmap: Optional[Costmap] = None
    planner_status: str = "initialized"  # Current status of the planner

    def __post_init__(self):
        if self.goals is None:
            self.goals = []

    def add_goal(self, goal: NavigationGoal):
        """Add a navigation goal to the plan."""
        if not isinstance(goal, NavigationGoal):
            raise ValueError("goal must be a NavigationGoal object")
        self.goals.append(goal)

    def validate(self) -> bool:
        """Validate the navigation plan configuration."""
        # Check required fields
        if not self.plan_id or not isinstance(self.plan_id, str):
            raise ValueError("plan_id must be a non-empty string")
        
        if not self.frame_id or not isinstance(self.frame_id, str):
            raise ValueError("frame_id must be a non-empty string")
        
        if not isinstance(self.global_plan, Path):
            raise ValueError("global_plan must be a Path object")
        
        # Validate optional fields if they exist
        if self.goals is not None:
            if not isinstance(self.goals, list):
                raise ValueError("goals must be a list of NavigationGoal objects")
            for goal in self.goals:
                if not isinstance(goal, NavigationGoal):
                    raise ValueError("All goals must be NavigationGoal objects")
        
        if self.local_plan is not None and not isinstance(self.local_plan, Path):
            raise ValueError("local_plan must be a Path object or None")
        
        if self.costmap is not None and not isinstance(self.costmap, Costmap):
            raise ValueError("costmap must be a Costmap object or None")
        
        # Validate planner status
        valid_statuses = ["initialized", "computing", "ready", "executing", "completed", "failed", "aborted"]
        if self.planner_status not in valid_statuses:
            raise ValueError(f"planner_status must be one of {valid_statuses}")
        
        return True

    def get_current_goal(self) -> Optional[NavigationGoal]:
        """Get the first goal that is not yet completed."""
        for goal in self.goals:
            if not goal.is_complete():
                return goal
        return None

    def get_completed_goals(self) -> List[NavigationGoal]:
        """Get all completed goals."""
        return [goal for goal in self.goals if goal.is_complete()]